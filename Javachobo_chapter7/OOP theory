	포함(composite)이란?
	- 클래스의 멤버로 참조변수를 선언하는 것
	- 작은 단위의 클래스를 만들고, 이 들을 조합해서 클래스를 만든다.
	
	상속관계 : A는 B이다.(is-a)
	포함관계 : A는 B를 가지고 있다.(has-a) 
	
	단일상속(Sing Inheritance)
	- Java는 단일상속만을 허용한다.
	- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.
	
	Object클래스 - 모든 클래스의 조상
	- 부모가 없는 클래스는 자동적으로 Object클래스를 상속받게 된다.
	- 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속받는다.
		toString(), equals(Object obj), hashCode(), ...
	- System.out.println(참조변수.toString());
		System.out.println(참조변수); --------------toString을 붙이지 않아도 결과는 같음
		
	오버라이딩(overriding)
	- 상속받은 조상의 메서드를 자신에 맞게 변경하는 것
	
	오버라이딩의 조건 
	1. 선언부가 조상 클래스의 메서드와 일치해야 한다.
		ㄴ 선언부 (반환타입, 메서드이름, 매개변수 목록)
	2. 접근제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
	3. 예외(exception)는 조상 클래스의 메서드보다 많이 선언할 수 없다.
	
	오버로딩 vs 오버라이딩
	- 오버로딩(overloading) : 기존에 없는 이름이 같은 새로운 메서드를 정의하는 것(new)
							상속과는 관계 없음
	- 오바리이딩(overriding) : 상속받은 메서드의 내용을 변경하는 것(change, modify)
	
	super() - 조상의 생성자
	- 조상의 생성자를 호출할 때 사용
	- 조상의 멤버는 조상의 생성자를 호출해서 초기화
	- 생성자의 첫 줄에 반드시 생성자를 호출해야 한다.
		그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입
		
	패키지(package)
	- 서로 관련딘 클래스의 묶음
	- 클래스는 클래스파일, 패키지는 폴더, 하위 패키지는 하위 폴더
	- 클래스의 실제 이름은 패키지를 포함
	
	제어자(modifier) - 형용사 같은 역할
	- 클래스오 클래스의 멤버(멤버 변수, ㅁ서드)에 부가적인 의미 부여
	- 접근 제어자 : public, protected, (default), private
		그외 : static, final, abstract native, ...
	- 하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 하나만 제일 왼쪽에)
	
	static - 클래스의, 공통적인
	- 멤버변수 :	1)모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
				2) 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
				3) 클래스가 메모리에 로드될 때 생성된다.
	- 메서드 :	1) 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
				2) static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.
	
	final - 마지막의, 변경될 수 없는
	- 클래스 :	변경될 수 없는 클래스 확장될 수 없는 클래스가 된다.
				그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
	- 메서드 :	변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.ㄴ
	-	멤버변수,
		지역변수 :	변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.
	
	abstract - 추상의, 미완성의
	- 클래스 :	클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
	- 메서드 :	선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.
	
	캡슐화와 접근 제어자
	- 접근 제어자를 사용하는 이유? 외부로부터 데이터를 보호하기 위해서
	
	다형성(polymorphism)
	- 여러 가지 형태를 가질 수 있는 능력
	- 조상 타입 참조 변수로 자손 타입 객체를 다루는 것
	- 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.
	- 참조변수의 타입은 인스턴스의 타입과 반드시 일치하나요? 보통 일치하지만 그렇지 않을 수 있음
		SmartTv s = new SmartTv();
		Tv		t = new SmartTv();
		(조상)				(자손)
	- 참조변수가 조상타입일 때와 자손타입일 때의 차이? 참조변수로 사용할 수 있는 멤버의 개수가 달라짐
	- 자손 타입의 참조변수로 자상 타입의 객체를 가리킬 수 있나요? 허용되지 않음
	
	참조변수의 형변환
	- 사용할 수 있는 멤버의 개수를 조절하는 것 (주소값, 객체 바뀌지 않고 개수만)
	- 조상 자손 관계의 참조변수는 서로 형변환 가능
	
	instanceof 연산자
	- 참조변수의 형변환 가능여부확인에 사용. 가능하면 true 반환 (자신과 모든 조상들이 다 true가 나옴)
		1) 확인 형변환 가능한지
		2) 형변환 실행
	- 형변환 전에 반드시 instanceof로 확인해야 함
	- 형변환 하는 이유는 인스턴스의 원래 기능을 모두 사용하기 위해서
		Car타입의 리모콘인 c로는 water()를 호출할 수 없으니까
		리모콘을 FireEngine타입으로 바꿔서 water()를 호출
	- 참조변수의 형변환 하는 이유는 참조변수(리모콘)을 변경함으로써 사용할 수 있는 멤버의 개수를 조절할 수 있다.
	- incetanceof 연산자는 참조변수를 형변환하기 전에 형변환 가능여부를 알기 위해 사용
	
	매개변수의 다형성
	- 장점 : 다형적 매개변수, 하나의 배열로 여러종류 객체 다루기
	- 참조형	매개변수는 메서드 호출시, 
			자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.
	- 다형성 :	1)조상 = 자손();
				2)참조변수의 형변환 -	리모콘바꾸기
									사용가능한 멤버개수 조절
				3)incetanceof 연산자 : 형변환 가능여부 확인
								